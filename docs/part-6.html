<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Part 6. Creational operators · RxJS Fundamentals</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# Creational operators"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Part 6. Creational operators · RxJS Fundamentals"/><meta property="og:type" content="website"/><meta property="og:url" content="https://this-is-learning.github.io/rxjs-fundamentals-course/"/><meta property="og:description" content="# Creational operators"/><meta property="og:image" content="https://this-is-learning.github.io/rxjs-fundamentals-course/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://this-is-learning.github.io/rxjs-fundamentals-course/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/rxjs-fundamentals-course/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/rxjs-fundamentals-course/js/scrollSpy.js"></script><link rel="stylesheet" href="/rxjs-fundamentals-course/css/main.css"/><script src="/rxjs-fundamentals-course/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/rxjs-fundamentals-course/"><img class="logo" src="/rxjs-fundamentals-course/img/favicon.ico" alt="RxJS Fundamentals"/><h2 class="headerTitleWithLogo">RxJS Fundamentals</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/rxjs-fundamentals-course/docs/part-1" target="_self">Course</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Part 6</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 1</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-1">Part 1. RxJS: better async programming</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 2</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-2">Part 2. Reactive programming and RxJS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 3</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-3">Part 3. The most common RxJS operators</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 4</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-4">Part 4. How RxJS is used by Angular</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 5</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-5">Part 5. Everything is a stream: Push-based architecture</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Part 6</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/rxjs-fundamentals-course/docs/part-6">Part 6. Creational operators</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Part 6. Creational operators</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="creational-operators"></a><a href="#creational-operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creational operators</h1>
<p>The following example demonstrates how to manually create an <code>Observable</code>:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> observable = <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribe</span>(<span class="hljs-params">observer</span>) </span>{
  <span class="hljs-keyword">const</span> id = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    observer.next(<span class="hljs-string">"Hello Rxjs"</span>);
    observer.complete();
  }, <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unsubscribe</span>(<span class="hljs-params"></span>) </span>{
    clearTimeout(id);
  };
});
</code></pre>
<p>Some are probably wondering: &quot;Do we have to remember this syntax to work with <code>Observable</code>? <code>next</code>, then <code>complete</code>, and also <code>unsubscribe</code>? This is a little too much of a hassle then&quot;. To answer this question, we will start exploring some <strong>Operators</strong> and <strong>Functions</strong> from <strong>RxJS</strong> that are used to create <code>Observable</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="preface"></a><a href="#preface" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preface</h2>
<p>This is a common <code>Observer</code> that we'll be using throughout this part. If there is any example that uses a different <code>Observer</code>, I'll point it out.</p>
<pre><code class="hljs css language-ts">const observer = {
  next: (val) =&gt; console.log('next:', val),
  error: (err) =&gt; console.log('error: err),
  complete: () =&gt; console.log('complete'),
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="of"></a><a href="#of" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>of()</code></h2>
<p>This is a function used to create an <code>Observable</code> from any type of value: primitives, Array, Object, Function etc... <code>of()</code> accepts all inputs and will <code>complete</code> as soon as all have been emitted.</p>
<h3><a class="anchor" aria-hidden="true" id="primitive"></a><a href="#primitive" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Primitive</h3>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - next: 'hello'
 * - complete
 */</span>
of(<span class="hljs-string">"hello"</span>).subscribe(observer);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="objectarray"></a><a href="#objectarray" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object/Array</h3>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - next: [1, 2, 3]
 * - complete
 */</span>
of([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).subscribe(observer);

<span class="hljs-comment">/**
 * output:
 * - next: {foo: 'bar'}
 * - complete
 */</span>
of({ foo: <span class="hljs-string">"bar"</span> }).subscribe(observer);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="sequence-of-values"></a><a href="#sequence-of-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sequence of values</h3>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - next: 1
 * - next: 2
 * - next: 3
 * - next: 'hello'
 * - next: 'world'
 * - next: {foo: 'bar'}
 * - next: [4, 5, 6]
 * - complete
 */</span>
of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, { foo: <span class="hljs-string">"bar"</span> }, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]).subscribe(observer);
</code></pre>
<p><code>of()</code> when called with no arguments will <code>complete</code> immediately without any <code>next</code> notification</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * complete
 */</span>
of().subscribe(observer);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="from"></a><a href="#from" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>from()</code></h2>
<p><code>from()</code>, similar to <code>of()</code>, is also a function that creates an <code>Observable</code> from some value. However, the difference between <code>from()</code> and <code>of()</code> is that <code>from()</code> only accepts value that is either an <code>Iterable</code>, or a <code>Promise</code>.</p>
<p><code>from()</code> also <code>completes</code> after it emits all values passed in.</p>
<blockquote>
<p>Iterable is value that can be iterated over. For example: an Array, an Object, a Map, a Set, or a String. When you iterate over a String, you'll receive each character in that string.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="array"></a><a href="#array" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array</h3>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - next: 1
 * - next: 2
 * - next: 3
 * - complete
 */</span>
<span class="hljs-keyword">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).subscribe(observer);
</code></pre>
<p>When <code>from()</code> receives an <code>Array</code>, it emits the items in sequence similarly to <code>of(1, 2, 3)</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="string"></a><a href="#string" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>String</h3>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - next: 'h'
 * - next: 'e'
 * - next: 'l'
 * - next: 'l'
 * - next: 'o'
 * - next: ' '
 * - next: 'w'
 * - next: 'o'
 * - next: 'r'
 * - next: 'l'
 * - next: 'd'
 * - complete: 'complete'
 */</span>
<span class="hljs-keyword">from</span>(<span class="hljs-string">"hello world"</span>).subscribe(observer);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mapset"></a><a href="#mapset" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Map/Set</h3>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> Map();
map.set(<span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>);
map.set(<span class="hljs-number">2</span>, <span class="hljs-string">"bye"</span>);

<span class="hljs-comment">/**
 * output:
 * - next: [1, 'hello']
 * - next: [2, 'bye']
 * - complete
 */</span>
<span class="hljs-keyword">from</span>(map).subscribe(observer);

<span class="hljs-keyword">const</span> <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> Set();
<span class="hljs-keyword">set</span>.add(<span class="hljs-number">1</span>);
<span class="hljs-keyword">set</span>.add(<span class="hljs-number">2</span>);

<span class="hljs-comment">/**
 * output:
 * - next: 1
 * - next: 2
 * - complete
 */</span>
<span class="hljs-keyword">from</span>(<span class="hljs-keyword">set</span>).subscribe(observer);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="promise"></a><a href="#promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise</h3>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * ouput:
 * - next: 'hello world'
 * - complete
 */</span>
<span class="hljs-keyword">from</span>(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">"hello world"</span>)).subscribe(observer);
</code></pre>
<p>In a case of a <code>Promise</code>, <code>from()</code> will unwrap the <code>Promise</code> and <code>next</code> the <code>resolved</code> value (or <code>error</code> the <code>rejected</code>). This is also the <em>official</em> way to convert a <code>Promise</code> to an `Observable.</p>
<h2><a class="anchor" aria-hidden="true" id="fromevent"></a><a href="#fromevent" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>fromEvent()</code></h2>
<p><code>fromEvent()</code> is used to convert an <code>Event</code> to an <code>Observable</code>. For example, <code>DOM Event</code> like a mouse click or typing in an Input.</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#btn"</span>);
<span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#input"</span>);

<span class="hljs-comment">/**
 * output:
 * - next: MouseEvent { ... }
 */</span>
fromEvent(btn, <span class="hljs-string">"click"</span>).subscribe(observer);

<span class="hljs-comment">/**
 * output:
 * - next: KeyboardEvent { ... }
 */</span>
fromEvent(input, <span class="hljs-string">"keydown"</span>).subscribe(observer);
</code></pre>
<p>Notice that <code>fromEvent()</code> creates an <code>Observable</code> that does not <code>complete</code> after emission. This makes total sense because for events like <code>click</code> or <code>keydown</code>, we would want to keep listening to these events for as long as we need to. In other words, for as long as these DOM Elements are presented to the consumers. <code>fromEvent()</code> cannot determine on its own when we no longer need to listen to these events. This also means that we will need to <code>unsubscribe</code> from these <code>Observable</code> manually to avoid <strong>memory-leak</strong>.</p>
<h2><a class="anchor" aria-hidden="true" id="fromeventpattern"></a><a href="#fromeventpattern" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>fromEventPattern()</code></h2>
<p><code>fromEventPattern()</code> is a <em>low-level</em> version of <code>fromEvent()</code>. Conceptually, it is similar to <code>fromEvent()</code> that is to create <code>Observable</code> from events. However, the usage is quite different. <code>fromEventPattern()</code> is used to convert <em>unconventional</em> or <em>callback-based</em> Events to <code>Observable</code>. To understand this better, let's look at some example:</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - next: MouseEvent {...}
 */</span>
fromEvent(btn, <span class="hljs-string">"click"</span>).subscribe(observer);

<span class="hljs-comment">/**
 * output:
 * - next: MouseEvent {...}
 */</span>
fromEventPattern(
  <span class="hljs-function">(<span class="hljs-params">handler</span>) =&gt;</span> {
    btn.addEventListener(<span class="hljs-string">"click"</span>, handler);
  },
  <span class="hljs-function">(<span class="hljs-params">handler</span>) =&gt;</span> {
    btn.removeEventListener(<span class="hljs-string">"click"</span>, handler);
  }
).subscribe(observer);
</code></pre>
<p>Another example:</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - next: 10 10
 */</span>
fromEvent(btn, <span class="hljs-string">"click"</span>)
  .pipe(map(<span class="hljs-function">(<span class="hljs-params">ev: MouseEvent</span>) =&gt;</span> ev.offsetX + <span class="hljs-string">" "</span> + ev.offsetY))
  .subscribe(observer);

<span class="hljs-comment">// fromEventPattern</span>
<span class="hljs-comment">// In this example, we'll break fromEventPattern() arguments into functions.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addHandler</span>(<span class="hljs-params">handler</span>) </span>{
  btn.addEventListener(<span class="hljs-string">"click"</span>, handler);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHandler</span>(<span class="hljs-params">handler</span>) </span>{
  btn.removeEventListener(<span class="hljs-string">"click"</span>, handler);
}

<span class="hljs-comment">/**
 * output:
 * - next: 10 10
 */</span>
fromEventPattern(
  addHandler,
  removeHandler,
  <span class="hljs-function">(<span class="hljs-params">ev: MouseEvent</span>) =&gt;</span> ev.offsetX + <span class="hljs-string">" "</span> + ev.offsetY
).subscribe(observer);
</code></pre>
<p>From these examples, we can tell that <code>fromEventPattern()</code> accepts 3 arguments: <code>addHandler</code>, <code>removeHandler</code>, and an optional <code>projectFunction</code>. Moreover, the behavior isn't that much different from <code>fromEvent()</code>.</p>
<p><code>fromEventPattern()</code> gives you the ability to convert the Events using their <em>original</em> APIs, like we're using the DOM API like <code>addEventListener</code> and <code>removeEventListener</code> to convert the <code>MouseEvent</code> to <code>Observable</code>. With this knowledge, you can apply <code>fromEventPattern()</code> with more complex Event APIs like <code>SignalR Hub</code>.</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">// _getHub() is an arbitrary function that returns a Hub</span>
<span class="hljs-keyword">const</span> hub = <span class="hljs-keyword">this</span>._getHub(url);

<span class="hljs-keyword">return</span> fromEventPattern(
  <span class="hljs-function">(<span class="hljs-params">handler</span>) =&gt;</span> {
    <span class="hljs-comment">// open the Websocket</span>
    hub.connection.on(methodName, handler);

    <span class="hljs-keyword">if</span> (hub.refCount === <span class="hljs-number">0</span>) {
      hub.connection.start();
    }

    hub.refCount++;
  },
  <span class="hljs-function">(<span class="hljs-params">handler</span>) =&gt;</span> {
    hub.refCount--;
    <span class="hljs-comment">// close the Websocket on Unsubscribe</span>
    hub.connection.off(methodName, handler);
    <span class="hljs-keyword">if</span> (hub.refCount === <span class="hljs-number">0</span>) {
      hub.connection.stop();
    }
  }
);
</code></pre>
<p>or <code>SocketIO</code></p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> SocketEventMap {
  event1: <span class="hljs-built_in">string</span>;
  event2: <span class="hljs-built_in">number</span>;
}

<span class="hljs-meta">@Injectable</span>({ providedIn: <span class="hljs-string">"root"</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SocketService {
  <span class="hljs-keyword">private</span> socket: Socket;

  <span class="hljs-comment">// init logic</span>

  on&lt;EventName <span class="hljs-keyword">extends</span> keyof SocketEventMap&gt;(
    event: EventName
  ): Observabe&lt;SocketEventMap&lt;EventName&gt;&gt; {
    <span class="hljs-keyword">return</span> fromEventPattern(
      <span class="hljs-function">(<span class="hljs-params">handler</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.socket?.on(event, handler);
      },
      <span class="hljs-function">(<span class="hljs-params">handler</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.socket?.off(event, handler);
      }
    );
  }
}

<span class="hljs-comment">// usage</span>
<span class="hljs-keyword">this</span>.socketService.on(<span class="hljs-string">"event1"</span>); <span class="hljs-comment">// Observable&lt;string&gt;</span>
<span class="hljs-keyword">this</span>.socketService.on(<span class="hljs-string">"event2"</span>); <span class="hljs-comment">// Observable&lt;number&gt;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="fromfetch"></a><a href="#fromfetch" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>fromFetch()</code></h2>
<p><code>fromFetch()</code> is used to convert <code>Fetch API</code> to <code>Observable</code>. The usage is identical to that of <code>fetch()</code>.</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">// Fetch API</span>
fetch(<span class="hljs-string">"https://jsonplaceholder.typicode.com/todos"</span>)
  .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.json())
  .then(<span class="hljs-function">(<span class="hljs-params">todos</span>) =&gt;</span> {
    <span class="hljs-comment">/*...*/</span>
  });

<span class="hljs-comment">// fromFetch()</span>
<span class="hljs-comment">/**
 * output:
 * - next: [{...}, {...}]
 * - complete
 */</span>
fromFetch(<span class="hljs-string">"https://jsonplaceholder.typicode.com/todos"</span>)
  .pipe(switchMap(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.json()))
  .subscribe(observer);
</code></pre>
<p>The main difference here is that <code>fetch()</code> is <code>Promise</code> based and is eager. As soon as we invoke <code>fetch()</code>, a request will be made. <code>fromFetch()</code> converts the request to <code>Observable</code> and makes it lazy. The request <strong>will not</strong> be made until we call <code>.subscribe()</code> on <code>fromFetch()</code>.</p>
<p>But wait, don't we already have <code>from()</code> for something like that? There is a <em>gotcha</em>.</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">from</span>(fetch(<span class="hljs-string">"https://jsonplaceholder.typicode.com/todos"</span>));
</code></pre>
<p>Notice that we haven't called <code>.subscribe()</code> and the request will still be made. This is because <code>fetch()</code> invokes a Promise eagerly as mentioned above.</p>
<h2><a class="anchor" aria-hidden="true" id="interval"></a><a href="#interval" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>interval()</code></h2>
<p><code>interval()</code> creates an <code>Observable</code> that emits integers from <code>0</code> in a specified interval.</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - (1s) next: 0
 * - (2s) next: 1
 * - (3s) next: 2
 * - ...
 */</span>
interval(<span class="hljs-number">1000</span>).subscribe(observer);
</code></pre>
<p><code>interval()</code> does not <code>complete</code> on its own so we will need to <code>unsubscribe</code> from <code>interval()</code> manually.</p>
<h2><a class="anchor" aria-hidden="true" id="timer"></a><a href="#timer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>timer()</code></h2>
<p><code>timer()</code> has two usages:</p>
<ul>
<li>Create an <code>Observable</code> that will emit number <code>0</code> after a specified <strong>delay</strong>. This usage of <code>timer()</code> will allow it to <code>complete</code> itself.</li>
<li>Create an <code>Observable</code> that will emit integers starting with <code>0</code> after a specified <strong>delay</strong>, then will emit each value after a specified <strong>interval</strong>. This sounds similar to <code>interval()</code> but there is a slight difference which we will explore in a bit. Because this second usage is like <code>interval()</code>, it will not <code>complete</code> on its own.</li>
</ul>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - (1s) next: 0
 * - complete
 */</span>
timer(<span class="hljs-number">1000</span>).subscribe(observer);

<span class="hljs-comment">/**
 * output:
 * - (1s) next: 0 (the first delay)
 * - (2s) next: 1 (1s interval)
 * - (3s) next: 2 (1s interval)
 * - ...
 */</span>
timer(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>).subscribe(observer);
</code></pre>
<p>So what's this <em>slight</em> difference? We can pass <code>0</code> as the first argument to <code>timer(0, 1000)</code> and this effectively gives us an <code>Observable</code> that emits <strong>right away</strong> then every <code>1s</code> after that. <code>interval()</code> alone cannot achieve this.</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - (immediate) next: 0
 * - (1s) next: 1 (1s interval)
 * - (2s) next: 2 (1s interval)
 * - ...
 */</span>
timer(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>).subscribe(observer);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="throwerror"></a><a href="#throwerror" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>throwError()</code></h2>
<p><code>throwError()</code> creates an <code>Observable</code> that, instead emits values, will throw an Error upon subscribe.</p>
<pre><code class="hljs css language-ts"><span class="hljs-comment">/**
 * output:
 * - error: 'an error'
 */</span>
throwError(<span class="hljs-string">"an error"</span>).subscribe(observer);
</code></pre>
<p><code>throwError()</code> is usually used with operators that requires an <code>Observable</code> as return value. Two main use-cases are:</p>
<ul>
<li><code>catchError()</code>: After we handle an error from an <code>Observable</code>, we can use <code>throwError()</code> to forward this error to the next <code>ErrorHandler</code></li>
</ul>
<pre><code class="hljs css language-ts">obs.pipe(
  catchError(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-comment">// handle error</span>
    showNotification(err.message);
    <span class="hljs-comment">// forward the error to the next ErrorHandler</span>
    <span class="hljs-keyword">return</span> throwError(err);
  })
);
</code></pre>
<ul>
<li><code>(switch|concat|merge)Map</code> + <code>retryWhen()</code>: This is an advanced use-case which we will explore further in <strong>Higher-order Operator</strong> post. The basic idea is we can use <code>throwError()</code> to force <code>retryWhen()</code> to occur which will <strong>retry</strong> the <code>Observable</code> pipeline.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="defer"></a><a href="#defer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>defer()</code></h2>
<p>This will be the last Creation Function that we will explore in this section, and it is an interesting one. <code>defer()</code> accepts an <code>ObservableFactory</code> (aka a <code>Function</code> that returns an <code>Observable</code>) to create a <em>deferred</em> version of the original <code>Observable</code>. What's special is that <code>defer()</code> will use <code>ObservableFactory</code> to create a new <code>Observable</code> for every new <code>Subscriber</code>. Let's explore in the following example:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> random$ = of(<span class="hljs-built_in">Math</span>.random()); <span class="hljs-comment">// create an Observable that emits random number</span>

<span class="hljs-comment">/**
 * output:
 * - next: 0.4146530439875191
 * - complete
 */</span>
random$.subscribe(observer);
<span class="hljs-comment">/**
 * output:
 * - next: 0.4146530439875191
 * - complete
 */</span>
random$.subscribe(observer);
<span class="hljs-comment">/**
 * output:
 * - next: 0.4146530439875191
 * - complete
 */</span>
random$.subscribe(observer);
</code></pre>
<p>We can see that <code>of()</code> returns the same result for all 3 subscribers. Let's try the same thing with <code>defer()</code></p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> deferredRandom$ = defer(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> of(<span class="hljs-built_in">Math</span>.random()));

<span class="hljs-comment">/**
 * output:
 * - next: 0.27312186273281935
 * - complete
 */</span>
deferredRandom$.subscribe(observer);
<span class="hljs-comment">/**
 * output:
 * - next: 0.7180321390218474
 * - complete
 */</span>
deferredRandom$.subscribe(observer);
<span class="hljs-comment">/**
 * output:
 * - next: 0.9626312890837065
 * - complete
 */</span>
deferredRandom$.subscribe(observer);
</code></pre>
<p>With <code>defer()</code>, we have 3 different results for 3 different subscribers. How does this help? Imagine you'd need to retry some <code>Observable</code> pipeline and at the beginning of this pipeline, you'd have a comparison against a value that can change, <code>defer()</code> makes sure that when the pipeline occurs (aka is <code>subscribed</code> to), the comparison happens with the latest values.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/rxjs-fundamentals-course/docs/part-5"><span class="arrow-prev">← </span><span>Part 5. Everything is a stream: Push-based architecture</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#preface">Preface</a></li><li><a href="#of"><code>of()</code></a><ul class="toc-headings"><li><a href="#primitive">Primitive</a></li><li><a href="#objectarray">Object/Array</a></li><li><a href="#sequence-of-values">Sequence of values</a></li></ul></li><li><a href="#from"><code>from()</code></a><ul class="toc-headings"><li><a href="#array">Array</a></li><li><a href="#string">String</a></li><li><a href="#mapset">Map/Set</a></li><li><a href="#promise">Promise</a></li></ul></li><li><a href="#fromevent"><code>fromEvent()</code></a></li><li><a href="#fromeventpattern"><code>fromEventPattern()</code></a></li><li><a href="#fromfetch"><code>fromFetch()</code></a></li><li><a href="#interval"><code>interval()</code></a></li><li><a href="#timer"><code>timer()</code></a></li><li><a href="#throwerror"><code>throwError()</code></a></li><li><a href="#defer"><code>defer()</code></a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/rxjs-fundamentals-course/" class="nav-home"><img src="/rxjs-fundamentals-course/img/favicon.ico" alt="RxJS Fundamentals" width="66" height="58"/></a><div><h5>Open Learning</h5><a href="/rxjs-fundamentals-course/docs/part-1">RxJS Fundamentals</a><a href="https://dev.to/this-is-learning" target="_blank" rel="noreferrer noopener">This is Learning publication</a><a href="https://dev.to/this-is-angular" target="_blank" rel="noreferrer noopener">This is Angular publication</a></div><div><h5>Community</h5><a href="https://discord.gg/ygKzbrBtVn" target="_blank" rel="noreferrer noopener">This is Learning Community Discord</a><a href="https://github.com/this-is-learning">This is Learning GitHub</a><a href="https://github.com/this-is-angular">This is Angular GitHub</a></div><div><h5>Social</h5><a class="github-button" data-icon="octicon-star" data-count-href="/this-is-learning/rxjs-fundamentals-course/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/Thisis_Learning" class="twitter-follow-button">Follow @Thisis_Learning</a></div></div></section><section class="copyright">Licensed under CC BY-SA 4.0 by This is Learning</section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>